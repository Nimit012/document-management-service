{"version":3,"sources":["../src/types/provider.types.ts","../src/types/errors.types.ts","../providers/google-drive/auth.ts","../providers/google-drive/operations.ts","../providers/google-drive/permissions.ts","../providers/google-drive/metadata.ts","../providers/google-drive/GoogleDriveProvider.ts","../src/DocumentManager.ts"],"names":["ProviderType"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\r\n * Supported storage provider types\r\n */\r\nexport enum ProviderType {\r\n  GOOGLE_DRIVE = 'google_drive',\r\n  S3 = 's3'\r\n}\r\n\r\n/**\r\n * Google Drive provider configuration\r\n */\r\nexport interface GoogleDriveConfig {\r\n    serviceAccountKey: ServiceAccountKey;  // Always an object\r\n    adminEmail: string; // The admin account that owns all documents\r\n  }\r\n  \r\n  /**\r\n   * Service account key structure (from Google Cloud)\r\n   */\r\n  export interface ServiceAccountKey {\r\n    type: string;\r\n    project_id: string;\r\n    private_key_id: string;\r\n    private_key: string;\r\n    client_email: string;\r\n    client_id: string;\r\n    auth_uri: string;\r\n    token_uri: string;\r\n    auth_provider_x509_cert_url: string;\r\n    client_x509_cert_url: string;\r\n  }\r\n  \r\n  /**\r\n   * S3 provider configuration (future)\r\n   */\r\n  export interface S3Config {\r\n    region: string;\r\n    bucket: string;\r\n    accessKeyId?: string;\r\n    secretAccessKey?: string;\r\n  }\r\n  \r\n  /**\r\n   * Union type for all provider configs\r\n   */\r\n  export type ProviderConfig = GoogleDriveConfig | S3Config;","/**\r\n * Base error for all library errors\r\n */\r\nexport class DocumentStorageError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'DocumentStorageError';\r\n      Object.setPrototypeOf(this, DocumentStorageError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Provider-specific errors (API failures, etc.)\r\n   */\r\n  export class ProviderError extends DocumentStorageError {\r\n    constructor(message: string, public originalError?: any) {\r\n      super(message);\r\n      this.name = 'ProviderError';\r\n      Object.setPrototypeOf(this, ProviderError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Validation errors (bad input)\r\n   */\r\n  export class ValidationError extends DocumentStorageError {\r\n    constructor(message: string) {\r\n      super(`Validation error: ${message}`);\r\n      this.name = 'ValidationError';\r\n      Object.setPrototypeOf(this, ValidationError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Resource not found errors\r\n   */\r\n  export class NotFoundError extends DocumentStorageError {\r\n    constructor(resourceType: string, resourceId: string) {\r\n      super(`${resourceType} not found: ${resourceId}`);\r\n      this.name = 'NotFoundError';\r\n      Object.setPrototypeOf(this, NotFoundError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Permission/authorization errors\r\n   */\r\n  export class PermissionError extends DocumentStorageError {\r\n    constructor(message: string) {\r\n      super(`Permission error: ${message}`);\r\n      this.name = 'PermissionError';\r\n      Object.setPrototypeOf(this, PermissionError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Feature not implemented by provider\r\n   */\r\n  export class NotImplementedError extends DocumentStorageError {\r\n    constructor(feature: string, provider: string) {\r\n      super(`Feature '${feature}' not implemented by provider '${provider}'`);\r\n      this.name = 'NotImplementedError';\r\n      Object.setPrototypeOf(this, NotImplementedError.prototype);\r\n    }\r\n  }","import { google } from 'googleapis';\r\nimport { GoogleAuth } from 'google-auth-library';\r\nimport { drive_v3 } from 'googleapis';\r\nimport { GoogleDriveConfig, ServiceAccountKey } from '../../src/types';\r\nimport { ProviderError } from '../../src/types';\r\n\r\n/**\r\n * Google authentication helper for Drive API operations.\r\n *\r\n * Handles authentication and client creation for the Google Drive API\r\n * using a service account with domain-wide delegation.\r\n *\r\n * Key concept: The service account can impersonate any user in the domain\r\n * by setting the 'subject' field in the clientOptions.\r\n */\r\nexport class GoogleAuthHelper {\r\n  /**\r\n   * The service account key used for authentication.\r\n   */\r\n  private serviceAccountKey: ServiceAccountKey;\r\n\r\n  /**\r\n   * The admin email address for the domain.\r\n   */\r\n  private adminEmail: string;\r\n\r\n  /**\r\n   * OAuth scopes required for Drive API access.\r\n   */\r\n  private scopes: string[];\r\n\r\n  /**\r\n   * Cache for Drive API client instances per impersonated user.\r\n   */\r\n  private driveClientCache: Map<string, drive_v3.Drive>;\r\n\r\n  /**\r\n   * Constructs a new GoogleAuthHelper instance.\r\n   * @param config Google Drive configuration with service account credentials.\r\n   */\r\n  constructor(config: GoogleDriveConfig) {\r\n    this.serviceAccountKey = config.serviceAccountKey;\r\n    this.adminEmail = config.adminEmail;\r\n\r\n    // Define OAuth scopes for required permissions\r\n    this.scopes = [\r\n      'https://www.googleapis.com/auth/drive', // Full Drive access\r\n    ];\r\n\r\n    // Initialize the Drive client cache\r\n    this.driveClientCache = new Map();\r\n\r\n    // Validate service account key structure\r\n    this.validateServiceAccountKey();\r\n  }\r\n\r\n  /**\r\n   * Validates that the service account key contains all required fields.\r\n   * @throws {ProviderError} If required fields are missing.\r\n   */\r\n  private validateServiceAccountKey(): void {\r\n    const required: (keyof ServiceAccountKey)[] = ['client_email', 'private_key'];\r\n    const missing = required.filter(field => !this.serviceAccountKey[field]);\r\n\r\n    if (missing.length > 0) {\r\n      throw new ProviderError(\r\n        `Service account key is missing required fields: ${missing.join(', ')}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a GoogleAuth client that impersonates a specific user.\r\n   *\r\n   * Domain-wide delegation steps:\r\n   * - Service account authenticates as itself.\r\n   * - Acts as the specified user (subject).\r\n   * - All API calls appear to come from that user.\r\n   *\r\n   * @param impersonateEmail Email of the user to impersonate.\r\n   * @returns Authenticated GoogleAuth client.\r\n   * @throws {ProviderError} If the client cannot be created.\r\n   */\r\n  private createAuthClient(impersonateEmail: string): GoogleAuth {\r\n    try {\r\n      const auth = new google.auth.GoogleAuth({\r\n        credentials: this.serviceAccountKey,\r\n        scopes: this.scopes,\r\n        clientOptions: {\r\n          subject: impersonateEmail, // Impersonation\r\n        },\r\n      });\r\n\r\n      return auth;\r\n    } catch (error) {\r\n      throw new ProviderError(\r\n        `Failed to create auth client for user: ${impersonateEmail}`,\r\n        error,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates an authenticated Google Drive API client for the impersonated user.\r\n   *\r\n   * All API calls will be made as the impersonated user.\r\n   *\r\n   * @param impersonateEmail Email of the user to impersonate.\r\n   * @returns Google Drive v3 API client.\r\n   * @throws {ProviderError} If the client cannot be created.\r\n   */\r\n  async createDriveClient(impersonateEmail: string): Promise<drive_v3.Drive> {\r\n    // Check cache first\r\n    if (this.driveClientCache.has(impersonateEmail)) {\r\n      return this.driveClientCache.get(impersonateEmail)!;\r\n    }\r\n\r\n    // Create new client\r\n    try {\r\n      const auth = this.createAuthClient(impersonateEmail);\r\n      \r\n      const driveClient = google.drive({\r\n        version: 'v3',\r\n        auth: auth,\r\n      });\r\n\r\n      // Cache the client\r\n      this.driveClientCache.set(impersonateEmail, driveClient);\r\n      return driveClient;\r\n    } catch (error) {\r\n      throw new ProviderError(\r\n        `Failed to create Drive client for user: ${impersonateEmail}`,\r\n        error,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the admin email for the domain.\r\n   * @returns The admin email address.\r\n   */\r\n  getAdminEmail(): string {\r\n    return this.adminEmail;\r\n  }\r\n\r\n  /**\r\n   * Creates an authenticated Google Drive API client for the admin user.\r\n   * \r\n   * This is a convenience method that automatically uses the admin email\r\n   * configured during initialization.\r\n   * \r\n   * @returns Google Drive v3 API client authenticated as admin.\r\n   */\r\n  async createAdminDriveClient(): Promise<drive_v3.Drive> {\r\n    return this.createDriveClient(this.adminEmail);\r\n  }\r\n}","import { drive_v3 } from 'googleapis';\r\nimport { GoogleAuthHelper } from './auth';\r\nimport { ProviderError, NotFoundError, Comment, Revision } from '../../src/types';\r\n\r\n/**\r\n * Helper for Google Drive document operations.\r\n *\r\n * This class provides comprehensive document management capabilities for Google Drive:\r\n *  - Copy documents between users with ownership transfer\r\n *  - Set and retrieve document permissions (read, write, comment access)\r\n *  - Create nested folder structures and manage folder hierarchy\r\n *  - Move documents between folders\r\n *  - Handle authentication and impersonation for multi-user operations\r\n *\r\n * All operations are performed using Google Drive API v3 with proper error handling\r\n * and support for domain-wide delegation to manage documents across user accounts.\r\n */\r\nexport class DocumentOperations {\r\n  /**\r\n   * Creates a new DocumentOperations instance.\r\n   * @param authHelper The GoogleAuthHelper used for authentication and impersonation.\r\n   */\r\n  constructor(private authHelper: GoogleAuthHelper) {}\r\n\r\n  /**\r\n   * Copies a document from the source owner's account.\r\n   *\r\n   * @param sourceDocId Source document ID to copy from.\r\n   * @param sourceOwnerEmail Email of the user who owns/can access the source.\r\n   * @param newName Name for the copied document (optional).\r\n   * @returns Copied file metadata as a Drive file object.\r\n   * @throws {NotFoundError} If the source document is not found.\r\n   * @throws {ProviderError} If the copy operation fails.\r\n   */\r\n  async copyDocument(\r\n    sourceDocId: string,\r\n    sourceOwnerEmail: string,\r\n    newName?: string\r\n  ): Promise<drive_v3.Schema$File> {\r\n    try {\r\n      const sourceDriveClient = await this.authHelper.createDriveClient(sourceOwnerEmail);\r\n\r\n      const copyResponse = await sourceDriveClient.files.copy({\r\n        fileId: sourceDocId,\r\n        requestBody: {\r\n          name: newName\r\n        },\r\n        fields: 'id,name,webViewLink,createdTime,modifiedTime,mimeType' // return these fields in response\r\n      });\r\n\r\n      return copyResponse.data;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', sourceDocId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to copy document: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get document metadata\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @returns Document metadata\r\n   */\r\n  async getDocument(documentId: string): Promise<drive_v3.Schema$File> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.files.get({\r\n        fileId: documentId,\r\n        fields: 'id,name,webViewLink,createdTime,modifiedTime,mimeType,properties'\r\n      });\r\n\r\n      if (!response.data) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to get document ${documentId}: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update document name\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @param newName - New document name\r\n   */\r\n  async updateName(documentId: string, newName: string): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      await adminDriveClient.files.update({\r\n        fileId: documentId,\r\n        requestBody: {\r\n          name: newName\r\n        }\r\n      });\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to update document name ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete document permanently\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   */\r\n  async deleteDocument(documentId: string): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      await adminDriveClient.files.delete({\r\n        fileId: documentId\r\n      });\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to delete document ${documentId}: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create nested folder path\r\n   *\r\n   * Example: \"us_history2/unit1/masters\"\r\n   * Creates:\r\n   * - us_history2/ (if doesn't exist)\r\n   * - us_history2/unit1/ (if doesn't exist)\r\n   * - us_history2/unit1/masters/ (if doesn't exist)\r\n   *\r\n   * Returns: ID of the final folder (masters)\r\n   *\r\n   * Always performed as admin\r\n   *\r\n   * @param path - Folder path (e.g., \"course/unit1/masters\")\r\n   * @returns ID of final folder in path\r\n   */\r\n  async createPath(path: string): Promise<string> {\r\n    try {\r\n      // Clean up path (remove leading/trailing slashes, empty segments)\r\n      const segments = path\r\n        .split('/')\r\n        .map((s) => s.trim())\r\n        .filter((s) => s.length > 0);\r\n\r\n      if (segments.length === 0) {\r\n        throw new ProviderError('Folder path cannot be empty');\r\n      }\r\n\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      let parentId: string | null = null;\r\n\r\n      // Create each folder in the path\r\n      for (const folderName of segments) {\r\n\r\n        parentId = await this._findOrCreateFolder(adminDriveClient, folderName, parentId);\r\n\r\n      }\r\n\r\n      return parentId!;\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to create folder path \"${path}\": ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find existing folder or create new one\r\n   *\r\n   * @param drive - Authenticated Drive client\r\n   * @param folderName - Name of folder to find/create\r\n   * @param parentId - Parent folder ID (null for root)\r\n   * @returns Folder ID\r\n   */\r\n  private async _findOrCreateFolder(\r\n    drive: drive_v3.Drive,\r\n    folderName: string,\r\n    parentId: string | null\r\n  ): Promise<string> {\r\n    // Step 1: Search for existing folder\r\n    const existingFolder = await this._findFolder(drive, folderName, parentId);\r\n\r\n    if (existingFolder) {\r\n      return existingFolder;\r\n    }\r\n\r\n    // Step 2: Create new folder if not found\r\n    return await this._createFolder(drive, folderName, parentId);\r\n  }\r\n\r\n  /**\r\n   * Search for existing folder\r\n   *\r\n   * @param drive - Authenticated Drive client\r\n   * @param folderName - Folder name to search for\r\n   * @param parentId - Parent folder ID (null for root)\r\n   * @returns Folder ID if found, null otherwise\r\n   */\r\n  private async _findFolder(\r\n    drive: drive_v3.Drive,\r\n    folderName: string,\r\n    parentId: string | null\r\n  ): Promise<string | null> {\r\n    try {\r\n      // Escape single quotes in folder name\r\n      const escapedName = folderName.replace(/'/g, \"\\\\'\");\r\n\r\n      // Build query\r\n      const queryParts = [\r\n        `name='${escapedName}'`,\r\n        `mimeType='application/vnd.google-apps.folder'`,\r\n        `trashed=false`\r\n      ];\r\n\r\n      // Add parent condition\r\n      if (parentId) {\r\n        queryParts.push(`'${parentId}' in parents`);\r\n      } else {\r\n        // Search in root (My Drive)\r\n        queryParts.push(`'root' in parents`);\r\n      }\r\n\r\n      const query = queryParts.join(' and ');\r\n\r\n      const response = await drive.files.list({\r\n        q: query,\r\n        fields: 'files(id,name)',\r\n        pageSize: 1 // We only need first match\r\n      });\r\n\r\n      const folders = response.data.files || [];\r\n\r\n      if (folders.length > 0) {\r\n        return folders[0].id!;\r\n      }\r\n\r\n      return null;\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      console.warn(`  ⚠️ Error searching for folder ${folderName}:`, errorMessage);\r\n      return null; // If search fails, we'll create it\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create new folder\r\n   *\r\n   * @param drive - Authenticated Drive client\r\n   * @param folderName - Name for new folder\r\n   * @param parentId - Parent folder ID (null for root)\r\n   * @returns New folder ID\r\n   */\r\n  private async _createFolder(\r\n    drive: drive_v3.Drive,\r\n    folderName: string,\r\n    parentId: string | null\r\n  ): Promise<string> {\r\n    const folderMetadata: drive_v3.Schema$File = {\r\n      name: folderName,\r\n      mimeType: 'application/vnd.google-apps.folder',\r\n      parents: parentId ? [parentId] : undefined\r\n    };\r\n\r\n    const response = await drive.files.create({\r\n      requestBody: folderMetadata,\r\n      fields: 'id,name'\r\n    });\r\n\r\n    if (!response.data || !response.data.id) {\r\n      throw new ProviderError(`Failed to create folder: ${folderName}`);\r\n    }\r\n\r\n    return response.data.id;\r\n  }\r\n\r\n  /**\r\n   * Moves a document to a specific folder.\r\n   * Removes document from all current parent folders and places in new folder.\r\n   * Always performed as admin.\r\n   *\r\n   * @param fileId The ID of the file to move.\r\n   * @param folderId The ID of the destination folder.\r\n   * @throws {ProviderError} If the move operation fails.\r\n   */\r\n  async moveToFolder(fileId: string, folderId: string): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Get current parents\r\n      const file = await adminDriveClient.files.get({\r\n        fileId: fileId,\r\n        fields: 'parents'\r\n      });\r\n\r\n      const previousParents = file.data.parents?.join(',') || '';\r\n\r\n      // Move file to new folder and remove from old parents\r\n      await adminDriveClient.files.update({\r\n        fileId: fileId,\r\n        addParents: folderId,\r\n        removeParents: previousParents,\r\n        fields: 'id,parents'\r\n      });\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to move document to folder: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves comments for a document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Comment objects.\r\n   * @throws {NotFoundError} If the document is not found.\r\n   * @throws {ProviderError} If the operation fails.\r\n   */\r\n  async getComments(documentId: string): Promise<Comment[]> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.comments.list({\r\n        fileId: documentId,\r\n        fields: 'comments(id,content,author,createdTime,resolved,replies)'\r\n      });\r\n\r\n      const comments = response.data.comments || [];\r\n\r\n      return comments.map((comment) => ({\r\n        comment_id: comment.id!,\r\n        author: comment.author?.displayName  || 'Unknown',\r\n        content: comment.content!,\r\n        created_at: comment.createdTime!,\r\n        resolved: comment.resolved || false,\r\n        replies: (comment.replies || []).map((reply) => ({\r\n          reply_id: reply.id!,\r\n          author: reply.author?.displayName  || 'Unknown',\r\n          content: reply.content!,\r\n          created_at: reply.createdTime!\r\n        }))\r\n      }));\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to get comments for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves revisions for a document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Revision objects.\r\n   * @throws {NotFoundError} If the document is not found.\r\n   * @throws {ProviderError} If the operation fails.\r\n   */\r\n  async getRevisions(documentId: string): Promise<Revision[]> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.revisions.list({\r\n        fileId: documentId,\r\n        fields: 'revisions(id,modifiedTime,lastModifyingUser,exportLinks)'\r\n      });\r\n\r\n      const revisions = response.data.revisions || [];\r\n\r\n      return revisions.map((rev) => ({\r\n        revision_id: rev.id!,\r\n        modified_time: rev.modifiedTime!,\r\n        modified_by: rev.lastModifyingUser?.emailAddress || 'Unknown',\r\n        export_links: rev.exportLinks || undefined\r\n      }));\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to get revisions for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n}\r\n","import { GoogleAuthHelper } from './auth';\r\nimport {AccessControl, ProviderError, NotFoundError } from '../../src/types';\r\n\r\n/**\r\n * Permission management for Google Drive documents.\r\n *\r\n * Handles ownership transfers and permission settings for documents.\r\n */\r\nexport class DocumentPermissions {\r\n  /**\r\n   * Helper for Google authentication and impersonation.\r\n   */\r\n  private authHelper: GoogleAuthHelper;\r\n\r\n  /**\r\n   * Constructs a new DocumentPermissions instance.\r\n   * @param authHelper The authentication helper for creating Drive clients.\r\n   */\r\n  constructor(authHelper: GoogleAuthHelper) {\r\n    this.authHelper = authHelper;\r\n  }\r\n\r\n  /**\r\n   * Transfers ownership of a document to the admin.\r\n   *\r\n   * @param sourceOwnerEmail Email of the current document owner.\r\n   * @param fileId The ID of the file to transfer ownership of.\r\n   * @throws {ProviderError} If the ownership transfer fails.\r\n   */\r\n  async transferToAdmin(sourceOwnerEmail: string, fileId: string): Promise<void> {\r\n    try {\r\n      const adminEmail = this.authHelper.getAdminEmail();\r\n      const sourceDriveClient = await this.authHelper.createDriveClient(sourceOwnerEmail);\r\n\r\n      await sourceDriveClient.permissions.create({\r\n        fileId: fileId,\r\n        requestBody: {\r\n          role: 'owner',\r\n          type: 'user',\r\n          emailAddress: adminEmail\r\n        },\r\n        transferOwnership: true\r\n      });\r\n\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const permissions = await adminDriveClient.permissions.list({\r\n        fileId: fileId,\r\n        fields: 'permissions(id,emailAddress,role)'\r\n      });\r\n\r\n      // Find teacher's permission\r\n      const teacherPermission = permissions.data.permissions?.find(\r\n        (p) => p.emailAddress === sourceOwnerEmail\r\n      );\r\n\r\n      if (teacherPermission?.id) {\r\n        await adminDriveClient.permissions.delete({\r\n          fileId: fileId,\r\n          permissionId: teacherPermission.id\r\n        });\r\n      }\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to transfer ownership to admin: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set permissions on a document\r\n   * Replaces ALL existing permissions except owner\r\n   * Always performed as admin\r\n   *\r\n   * Flow:\r\n   * 1. Get all existing permissions\r\n   * 2. Delete all non-owner permissions\r\n   * 3. Create new permissions from accessControl array\r\n   *\r\n   * @param documentId - Document ID\r\n   * @param accessControl - Array of access control rules\r\n   */\r\n  async setPermissions(documentId: string, accessControl: AccessControl[]): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Step 1: Get existing permissions\r\n      const existingPermissions = await adminDriveClient.permissions.list({\r\n        fileId: documentId,\r\n        fields: 'permissions(id,role,emailAddress,type)'\r\n      });\r\n\r\n      const permissions = existingPermissions.data.permissions || [];\r\n\r\n      // Step 2: Delete all non-owner permissions\r\n      for (const permission of permissions) {\r\n        // Never delete owner permission\r\n        if (permission.role === 'owner') {\r\n          continue;\r\n        }\r\n\r\n        if (permission.id) {\r\n          try {\r\n            await adminDriveClient.permissions.delete({\r\n              fileId: documentId,\r\n              permissionId: permission.id\r\n            });\r\n          } catch (error) {\r\n            console.warn(`Failed to remove permission ${permission.id}:`, error);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Step 3: Create new permissions\r\n      for (const ac of accessControl) {\r\n        const role = this._mapAccessLevelToRole(ac.access_level);\r\n\r\n        await adminDriveClient.permissions.create({\r\n          fileId: documentId,\r\n          requestBody: {\r\n            role: role,\r\n            type: 'user',\r\n            emailAddress: ac.user\r\n          },\r\n          sendNotificationEmail: false // Don't spam users with emails\r\n        });\r\n\r\n      }\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to set permissions on document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current permissions on a document\r\n   * Excludes owner permission\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @returns Array of access control rules\r\n   */\r\n  async getPermissions(documentId: string): Promise<AccessControl[]> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.permissions.list({\r\n        fileId: documentId,\r\n        fields: 'permissions(id,role,emailAddress,type)'\r\n      });\r\n\r\n      const permissions = response.data.permissions || [];\r\n\r\n      // Filter out owner and convert to AccessControl format\r\n      const accessControl: AccessControl[] = permissions\r\n        .filter((p) => p.role !== 'owner' && p.emailAddress)\r\n        .map((p) => ({\r\n          user: p.emailAddress!,\r\n          access_level: this._mapRoleToAccessLevel(p.role!)\r\n        }));\r\n\r\n      return accessControl;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to get permissions for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Map our access level to Google Drive role\r\n   *\r\n   * @param accessLevel - Our access level (read, read_write, comment)\r\n   * @returns Google Drive role (reader, writer, commenter)\r\n   */\r\n  private _mapAccessLevelToRole(accessLevel: string): string {\r\n    const mapping: Record<string, string> = {\r\n      read: 'reader',\r\n      read_write: 'writer',\r\n      comment: 'commenter'\r\n    };\r\n\r\n    const role = mapping[accessLevel];\r\n    if (!role) {\r\n      throw new ProviderError(\r\n        `Invalid access level: ${accessLevel}. Must be read, read_write, or comment`\r\n      );\r\n    }\r\n\r\n    return role;\r\n  }\r\n\r\n  /**\r\n   * Map Google Drive role to our access level\r\n   *\r\n   * @param role - Google Drive role (reader, writer, commenter)\r\n   * @returns Our access level (read, read_write, comment)\r\n   */\r\n  private _mapRoleToAccessLevel(role: string): 'read' | 'read_write' | 'comment' {\r\n    const mapping: Record<string, 'read' | 'read_write' | 'comment'> = {\r\n      reader: 'read',\r\n      writer: 'read_write',\r\n      commenter: 'comment'\r\n    };\r\n\r\n    return mapping[role] || 'read'; // Default to read if unknown\r\n  }\r\n}\r\n","import { GoogleAuthHelper } from './auth';\r\nimport { Document, NotFoundError, ProviderError, SearchDocumentsResult } from '../../src/types';\r\nimport { drive_v3 } from 'googleapis';\r\n\r\n/**\r\n * Metadata management for Google Drive documents.\r\n *\r\n * Handles retrieval and updates of document metadata.\r\n */\r\nexport class DocumentMetadata {\r\n  /**\r\n   * Helper for Google authentication and impersonation.\r\n   */\r\n  private authHelper: GoogleAuthHelper;\r\n\r\n  /**\r\n   * Constructs a new DocumentMetadata instance.\r\n   * @param authHelper The authentication helper for creating Drive clients.\r\n   */\r\n  constructor(authHelper: GoogleAuthHelper) {\r\n    this.authHelper = authHelper;\r\n  }\r\n\r\n  /**\r\n   * Set custom metadata on a document\r\n   * Stored as Google Drive file properties\r\n   * Always performed as admin\r\n   *\r\n   * Note: Google Drive properties are key-value strings.\r\n   * Non-string values are JSON-stringified.\r\n   *\r\n   * @param documentId - Document ID\r\n   * @param metadata - Key-value metadata object\r\n   */\r\n  async setMetadata(documentId: string, metadata: Record<string, unknown>): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Convert all values to strings (Google Drive requirement)\r\n      const properties: Record<string, string> = {};\r\n      for (const [key, value] of Object.entries(metadata)) {\r\n        if (value === null || value === undefined) {\r\n          properties[key] = '';\r\n        } else if (typeof value === 'string') {\r\n          properties[key] = value;\r\n        } else {\r\n          // JSON stringify objects, numbers, booleans, arrays\r\n          properties[key] = JSON.stringify(value);\r\n        }\r\n      }\r\n\r\n      await adminDriveClient.files.update({\r\n        fileId: documentId,\r\n        requestBody: {\r\n          properties: properties\r\n        },\r\n        fields: 'properties'\r\n      });\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to set metadata on document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get custom metadata from a document\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @returns Metadata object (with values parsed back from strings)\r\n   */\r\n  async getMetadata(documentId: string): Promise<Record<string, unknown>> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.files.get({\r\n        fileId: documentId,\r\n        fields: 'properties'\r\n      });\r\n\r\n      const properties = response.data.properties || {};\r\n\r\n      // Parse values back (attempt JSON parse, fallback to string)\r\n      const metadata: Record<string, unknown> = {};\r\n      for (const [key, value] of Object.entries(properties)) {\r\n        if (value === '') {\r\n          metadata[key] = null;\r\n        } else {\r\n          try {\r\n            // Try to parse as JSON (for objects, numbers, booleans, arrays)\r\n            metadata[key] = JSON.parse(value);\r\n          } catch {\r\n            // Not JSON, keep as string\r\n            metadata[key] = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      return metadata;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n      throw new ProviderError(\r\n        `Failed to get metadata for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search documents by metadata filters with token-based pagination.\r\n   * Uses Google Drive query API to search by custom properties.\r\n   * Always performed as admin.\r\n   *\r\n   * Example filters:\r\n   * { activity_id: 'act_123', document_type: 'student_copy' }\r\n   *\r\n   * Becomes Google Drive query:\r\n   * \"properties has { key='activity_id' and value='act_123' } and\r\n   *  properties has { key='document_type' and value='student_copy' }\"\r\n   *\r\n   * @param filters - Metadata key-value filters\r\n   * @param limit - Maximum results per page (default: 20, max: 100)\r\n   * @param pageToken - Token from previous response for next page\r\n   * @returns Search results with documents and next page token\r\n   */\r\n  async searchByMetadata(\r\n    filters: Record<string, unknown>,\r\n    limit: number = 20,\r\n    pageToken?: string\r\n  ): Promise<SearchDocumentsResult> {\r\n    try {\r\n      // Validate limit\r\n      if (limit < 1 || limit > 100) {\r\n        throw new ProviderError('Limit must be between 1 and 100');\r\n      }\r\n\r\n      const adminDrive = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Build query from filters\r\n      const queryParts: string[] = [];\r\n\r\n      for (const [key, value] of Object.entries(filters)) {\r\n        // Convert value to string (same as setMetadata)\r\n        let stringValue: string;\r\n        if (value === null || value === undefined) {\r\n          stringValue = '';\r\n        } else if (typeof value === 'string') {\r\n          stringValue = value;\r\n        } else {\r\n          stringValue = JSON.stringify(value);\r\n        }\r\n\r\n        // Escape single quotes in value\r\n        const escapedValue = stringValue.replace(/'/g, \"\\\\'\");\r\n\r\n        // Build query part\r\n        queryParts.push(`properties has { key='${key}' and value='${escapedValue}' }`);\r\n      }\r\n\r\n      // Add \"not trashed\" filter\r\n      queryParts.push('trashed=false');\r\n\r\n      // Combine all query parts\r\n      const query = queryParts.join(' and ');\r\n\r\n      // Execute search with pagination\r\n      const response = await adminDrive.files.list({\r\n        q: query,\r\n        fields:\r\n          'nextPageToken, files(id,name,webViewLink,createdTime,modifiedTime,mimeType,properties)',\r\n        pageSize: limit,\r\n        pageToken: pageToken, // Use token if provided\r\n        orderBy: 'modifiedTime desc' // Most recently modified first\r\n      });\r\n\r\n      const files = response.data.files || [];\r\n      const nextPageToken = response.data.nextPageToken;\r\n\r\n      // Transform to Document format\r\n      const documents: Document[] = files.map((file) => this._toDocumentObject(file));\r\n\r\n      return {\r\n        documents,\r\n        nextPageToken,\r\n        limit\r\n      };\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n      throw new ProviderError(`Failed to search documents by metadata ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts a Google Drive file object to the internal Document format.\r\n   *\r\n   * @param file The Google Drive file to convert.\r\n   * @returns The corresponding Document object.\r\n   */\r\n  private _toDocumentObject(file: drive_v3.Schema$File): Document {\r\n    // Convert Google Drive properties to metadata\r\n    const metadata: Record<string, unknown> = {};\r\n\r\n    if (file.properties) {\r\n      for (const [key, value] of Object.entries(file.properties)) {\r\n        if (value !== null && value !== undefined) {\r\n          // Try to parse JSON values, otherwise keep as string\r\n          try {\r\n            metadata[key] = JSON.parse(value);\r\n          } catch {\r\n            metadata[key] = value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      document_id: file.id!,\r\n      storage_reference: file.id!,\r\n      name: file.name || 'Untitled',\r\n      access_url: file.webViewLink || `https://docs.google.com/document/d/${file.id}/edit`,\r\n      created_at: file.createdTime || new Date().toISOString(),\r\n      updated_at: file.modifiedTime || undefined,\r\n      metadata: Object.keys(metadata).length > 0 ? metadata : undefined\r\n    };\r\n  }\r\n}\r\n","import { drive_v3 } from 'googleapis';\r\nimport { IStorageProvider } from '../IStorageProvider';\r\nimport {\r\n  Document,\r\n  CreateDocumentRequest,\r\n  GoogleDriveConfig,\r\n  ProviderError,\r\n  AccessControl,\r\n  SearchDocumentsResult,\r\n  Comment,\r\n  Revision\r\n} from '../../src/types';\r\nimport { GoogleAuthHelper } from './auth';\r\nimport { DocumentOperations } from './operations';\r\nimport { DocumentPermissions } from './permissions';\r\nimport { DocumentMetadata } from './metadata';\r\n\r\n/**\r\n * Google Drive Storage Provider implementation.\r\n *\r\n * Implements the {@link IStorageProvider} interface for Google Drive.\r\n * Orchestrates authentication, document operations, permissions, and metadata\r\n * to provide complete document management functionality.\r\n */\r\nexport class GoogleDriveProvider implements IStorageProvider {\r\n  /**\r\n   * Helper for Google authentication and impersonation.\r\n   */\r\n  private authHelper: GoogleAuthHelper;\r\n\r\n  /**\r\n   * Handles document-level operations (copy, move, get, folder management).\r\n   */\r\n  private operations: DocumentOperations;\r\n\r\n  /**\r\n   * Handles permission and ownership operations.\r\n   */\r\n  private permissions: DocumentPermissions;\r\n\r\n  /**\r\n   * Handles metadata operations.\r\n   */\r\n  private metadata: DocumentMetadata;\r\n\r\n  /**\r\n   * Constructs a new GoogleDriveProvider instance.\r\n   * @param config The configuration object for Google Drive integration.\r\n   */\r\n  constructor(config: GoogleDriveConfig) {\r\n    this.authHelper = new GoogleAuthHelper(config);\r\n    this.operations = new DocumentOperations(this.authHelper);\r\n    this.permissions = new DocumentPermissions(this.authHelper);\r\n    this.metadata = new DocumentMetadata(this.authHelper);\r\n  }\r\n\r\n  // ==================== DOCUMENT OPERATIONS ====================\r\n\r\n  /**\r\n   * Copies a document in Google Drive according to the request details.\r\n   *\r\n   * Steps:\r\n   * 1. Copies the source document, impersonating the source owner.\r\n   * 2. Transfers ownership to admin.\r\n   * 3. Creates the target folder structure if `folder_path` is provided and moves document.\r\n   * 4. Sets permissions if `access_control` is specified.\r\n   * 5. Sets metadata if `metadata` is specified.\r\n   * 6. Transforms the copied file into the Document format.\r\n   *\r\n   * @param request The document creation request, including source reference, owner, name, folder path, access control, and metadata.\r\n   * @returns The created Document object.\r\n   * @throws {ProviderError} If any step fails during the process.\r\n   */\r\n  async copyDocumentFromSource(request: CreateDocumentRequest): Promise<Document> {\r\n    try {\r\n      // 1. Copy document\r\n      const copiedFile = await this.operations.copyDocument(\r\n        request.source_reference,\r\n        request.source_owner,\r\n        request.name\r\n      );\r\n\r\n      // 2. Transfer ownership to admin\r\n      await this.permissions.transferToAdmin(request.source_owner, copiedFile.id!);\r\n\r\n      // 3. Move to folder (if specified)\r\n      if (request.folder_path) {\r\n        const folderId = await this.operations.createPath(request.folder_path);\r\n        await this.operations.moveToFolder(copiedFile.id!, folderId);\r\n      }\r\n\r\n      // 4. Set permissions (if specified)\r\n      if (request.access_control && request.access_control.length > 0) {\r\n        await this.permissions.setPermissions(copiedFile.id!, request.access_control);\r\n      }\r\n\r\n      // 5. Set metadata (if specified)\r\n      if (request.metadata) {\r\n        await this.metadata.setMetadata(copiedFile.id!, request.metadata);\r\n      }\r\n\r\n      // 6. Transform to Document\r\n      return this._toDocumentObject(copiedFile);\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to create document: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves a document's metadata from Google Drive and transforms it into the Document format.\r\n   *\r\n   * @param documentId - The unique identifier of the Google Drive document.\r\n   * @returns The corresponding Document object in the internal format.\r\n   */\r\n  async getDocument(documentId: string): Promise<Document> {\r\n    const file = await this.operations.getDocument(documentId);\r\n    return this._toDocumentObject(file);\r\n  }\r\n\r\n  /**\r\n   * Updates a document's name and/or metadata in Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - ID of the document to update.\r\n   * @param updates - Object containing the new name and/or metadata to set.\r\n   * @returns The updated Document object.\r\n   */\r\n  async updateDocument(\r\n    documentId: string,\r\n    updates: { name?: string; metadata?: Record<string, unknown> }\r\n  ): Promise<Document> {\r\n    try {\r\n      // Update name if provided\r\n      if (updates.name) {\r\n        await this.operations.updateName(documentId, updates.name);\r\n      }\r\n\r\n      // Update metadata if provided\r\n      if (updates.metadata) {\r\n        // Merge with existing metadata\r\n        const existingMetadata = await this.metadata.getMetadata(documentId);\r\n        const mergedMetadata = { ...existingMetadata, ...updates.metadata };\r\n        await this.metadata.setMetadata(documentId, mergedMetadata);\r\n      }\r\n\r\n      // Return updated document\r\n      return await this.getDocument(documentId);\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to update document: ${errorMessage}`, error);\r\n    }\r\n  }\r\n  /**\r\n   * Deletes a document permanently by its ID from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document to delete.\r\n   * @returns A promise that resolves when the document is deleted.\r\n   */\r\n  async deleteDocument(documentId: string): Promise<void> {\r\n    await this.operations.deleteDocument(documentId);\r\n  }\r\n\r\n  /**\r\n   * Sets access permissions for a document, replacing all existing non-owner permissions.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document to update permissions for.\r\n   * @param accessControl - Array of AccessControl rules to apply.\r\n   * @returns A promise that resolves when permissions are set.\r\n   */\r\n  async setPermissions(documentId: string, accessControl: AccessControl[]): Promise<void> {\r\n    await this.permissions.setPermissions(documentId, accessControl);\r\n  }\r\n\r\n\r\n  \r\n  /**\r\n   * Searches for documents by metadata filters in Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param filters - Key-value pairs of metadata fields to filter.\r\n   * @param limit - Maximum number of documents to return (default: 20).\r\n   * @param offset - Pagination offset (default: 0).\r\n   * @returns A promise resolving to a SearchDocumentsResult with found documents.\r\n   */\r\n  async searchByMetadata(\r\n    filters: Record<string, unknown>,\r\n    limit: number = 20,\r\n    pageToken?: string\r\n  ): Promise<SearchDocumentsResult> {\r\n    return await this.metadata.searchByMetadata(filters, limit, pageToken);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Retrieves comments for a specific document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Comment objects.\r\n   */\r\n  async getComments(documentId: string): Promise<Comment[]> {\r\n    return await this.operations.getComments(documentId);\r\n  }\r\n\r\n  /**\r\n   * Retrieves revision history for a specific document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Revision objects.\r\n   */\r\n  async getRevisions(documentId: string): Promise<Revision[]> {\r\n    return await this.operations.getRevisions(documentId);\r\n  }\r\n  \r\n\r\n  // ==================== HELPER METHODS ====================\r\n\r\n  /**\r\n   * Converts a Google Drive file object to the internal Document format.\r\n   *\r\n   * @param file The Google Drive file to convert.\r\n   * @returns The corresponding Document object.\r\n   */\r\n  private _toDocumentObject(file: drive_v3.Schema$File): Document {\r\n    // Convert Google Drive properties to metadata\r\n    const metadata: Record<string, unknown> = {};\r\n\r\n    if (file.properties) {\r\n      for (const [key, value] of Object.entries(file.properties)) {\r\n        if (value !== null && value !== undefined) {\r\n          // Try to parse JSON values, otherwise keep as string\r\n          try {\r\n            metadata[key] = JSON.parse(value);\r\n          } catch {\r\n            metadata[key] = value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      document_id: file.id!,\r\n      storage_reference: file.id!,\r\n      name: file.name || 'Untitled',\r\n      access_url: file.webViewLink || `https://docs.google.com/document/d/${file.id}/edit`,\r\n      created_at: file.createdTime || new Date().toISOString(),\r\n      updated_at: file.modifiedTime || undefined,\r\n      metadata: Object.keys(metadata).length > 0 ? metadata : undefined\r\n    };\r\n  }\r\n}\r\n","import { GoogleDriveProvider } from '../providers/google-drive/GoogleDriveProvider';\r\nimport {\r\n  Document,\r\n  CreateDocumentRequest,\r\n  GoogleDriveConfig,\r\n  ValidationError,\r\n  ProviderType,\r\n  AccessControl,\r\n  SearchDocumentsResult,\r\n  Comment,\r\n  Revision\r\n} from './types';\r\n\r\nimport { IStorageProvider } from '../providers/IStorageProvider';\r\n\r\n/**\r\n * Configuration options for the DocumentManager.\r\n * @property provider The type of storage provider ('google_drive' or 's3').\r\n * @property config Provider-specific configuration. Currently only GoogleDriveConfig is supported.\r\n */\r\ninterface DocumentManagerConfig {\r\n  /** The type of storage provider to use. */\r\n  provider: ProviderType;\r\n\r\n  /** Provider-specific configuration. */\r\n  config: GoogleDriveConfig; // Will be union type when S3 added\r\n}\r\n\r\n/**\r\n * Main facade class providing a unified interface for document operations.\r\n * Automatically instantiates the correct storage provider based on configuration.\r\n */\r\nexport class DocumentManager {\r\n  /** The underlying storage provider instance. */\r\n  private provider: IStorageProvider;\r\n\r\n  /**\r\n   * Constructs a DocumentManager instance with the specified configuration.\r\n   * @param options Configuration for selecting and initializing the storage provider.\r\n   * @throws {ValidationError} If the provider type is unsupported.\r\n   * @throws {Error} If the S3 provider is selected (not yet implemented).\r\n   */\r\n  constructor(options: DocumentManagerConfig) {\r\n    // Create provider based on type\r\n    if (options.provider === ProviderType.GOOGLE_DRIVE) {\r\n      this.provider = new GoogleDriveProvider(options.config);\r\n    } else if (options.provider === ProviderType.S3) {\r\n      throw new Error('S3 provider not yet implemented');\r\n    } else {\r\n      throw new ValidationError(`Unsupported provider: ${options.provider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new document from the specified source.\r\n   * @param request Details for the document to be created.\r\n   * @returns The created Document object.\r\n   */\r\n  async createDocument(request: CreateDocumentRequest): Promise<Document> {\r\n    return await this.provider.copyDocumentFromSource(request);\r\n  }\r\n\r\n  /**\r\n   * Get document by ID\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to the found Document object, if it exists.\r\n   */\r\n  async getDocument(documentId: string): Promise<Document> {\r\n    return await this.provider.getDocument(documentId);\r\n  }\r\n\r\n  /**\r\n   * Updates a document's name and/or metadata.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - ID of the document to update.\r\n   * @param updates - Object containing the new name and/or metadata to set.\r\n   * @returns The updated Document object.\r\n   */\r\n  async updateDocument(\r\n    documentId: string,\r\n    updates: { name?: string; metadata?: Record<string, unknown> }\r\n  ): Promise<Document> {\r\n    return await this.provider.updateDocument(documentId, updates);\r\n  }\r\n\r\n  /**\r\n   * Deletes a document permanently by its document ID.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document to delete.\r\n   * @returns A promise that resolves when the document is deleted.\r\n   */\r\n  async deleteDocument(documentId: string): Promise<void> {\r\n    return await this.provider.deleteDocument(documentId);\r\n  }\r\n\r\n  /**\r\n   * Sets the access control (permissions) for a document, replacing all existing permissions.\r\n   *\r\n   * @param documentId - The unique identifier of the document to update permissions for.\r\n   * @param accessControl - An array of AccessControl objects specifying the new permissions.\r\n   * @returns A promise that resolves when permissions are set.\r\n   */\r\n  async setAccessControl(documentId: string, accessControl: AccessControl[]): Promise<void> {\r\n    return await this.provider.setPermissions(documentId, accessControl);\r\n  }\r\n\r\n  /**\r\n   * Lists or searches for documents matching the provided metadata filters.\r\n   *\r\n   * @param filters - An object containing metadata key-value pairs to filter documents.\r\n   * @param limit - The maximum number of documents to retrieve (default: 20).\r\n   * @param offset - The number of documents to skip before starting to collect the result set (default: 0).\r\n   * @returns A promise that resolves to a SearchDocumentsResult containing the found documents and any pagination info.\r\n   */\r\n  async listDocuments(\r\n    filters: Record<string, unknown>,\r\n    limit: number = 20,\r\n    pageToken?: string\r\n  ): Promise<SearchDocumentsResult> {\r\n    return await this.provider.searchByMetadata(filters, limit, pageToken);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Retrieves comments for a given document, if supported by the provider.\r\n   *\r\n   * @param documentId - The unique identifier of the document to get comments for.\r\n   * @returns A promise that resolves to an array of Comment objects.\r\n   * @throws Error if comments are not supported by the underlying provider.\r\n   */\r\n  async getComments(documentId: string): Promise<Comment[]> {\r\n    \r\n    if (!this.provider.getComments) {\r\n      throw new Error('Comments not supported by this provider');\r\n    }\r\n    \r\n    return await this.provider.getComments(documentId);\r\n  }\r\n\r\n\r\n  /**\r\n   * Retrieves the revision history for a given document, if supported by the provider.\r\n   *\r\n   * @param documentId - The unique identifier of the document to get revisions for.\r\n   * @returns A promise that resolves to an array of Revision objects.\r\n   * @throws Error if revisions are not supported by the underlying provider.\r\n   */\r\n  async getRevisions(documentId: string): Promise<Revision[]> {\r\n    \r\n    if (!this.provider.getRevisions) {\r\n      throw new Error('Revisions not supported by this provider');\r\n    }\r\n    \r\n    return await this.provider.getRevisions(documentId);\r\n  }\r\n}\r\n"]}