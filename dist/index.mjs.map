{"version":3,"file":"index.mjs","names":["originalError?: any","authHelper: GoogleAuthHelper","error: unknown","parentId: string | null","folderMetadata: drive_v3.Schema$File","error: unknown","properties: Record<string, string>","error: unknown","metadata: Record<string, unknown>","queryParts: string[]","stringValue: string","error: unknown","metadata: Record<string, unknown>"],"sources":["../src/types/provider.types.ts","../src/types/errors.types.ts","../providers/google-drive/auth.ts","../providers/google-drive/operations.ts","../providers/google-drive/permissions.ts","../providers/google-drive/metadata.ts","../providers/google-drive/GoogleDriveProvider.ts","../src/DocumentManager.ts"],"sourcesContent":["/**\r\n * Supported storage provider types\r\n */\r\nexport enum ProviderType {\r\n  GOOGLE_DRIVE = 'google_drive',\r\n  S3 = 's3'\r\n}\r\n\r\n/**\r\n * Google Drive provider configuration\r\n */\r\nexport interface GoogleDriveConfig {\r\n    serviceAccountKey: ServiceAccountKey;  // Always an object\r\n    adminEmail: string; // The admin account that owns all documents\r\n  }\r\n  \r\n  /**\r\n   * Service account key structure (from Google Cloud)\r\n   */\r\n  export interface ServiceAccountKey {\r\n    type: string;\r\n    project_id: string;\r\n    private_key_id: string;\r\n    private_key: string;\r\n    client_email: string;\r\n    client_id: string;\r\n    auth_uri: string;\r\n    token_uri: string;\r\n    auth_provider_x509_cert_url: string;\r\n    client_x509_cert_url: string;\r\n  }\r\n  \r\n  /**\r\n   * S3 provider configuration (future)\r\n   */\r\n  export interface S3Config {\r\n    region: string;\r\n    bucket: string;\r\n    accessKeyId?: string;\r\n    secretAccessKey?: string;\r\n  }\r\n  \r\n  /**\r\n   * Union type for all provider configs\r\n   */\r\n  export type ProviderConfig = GoogleDriveConfig | S3Config;","/**\r\n * Base error for all library errors\r\n */\r\nexport class DocumentStorageError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'DocumentStorageError';\r\n      Object.setPrototypeOf(this, DocumentStorageError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Provider-specific errors (API failures, etc.)\r\n   */\r\n  export class ProviderError extends DocumentStorageError {\r\n    constructor(message: string, public originalError?: any) {\r\n      super(message);\r\n      this.name = 'ProviderError';\r\n      Object.setPrototypeOf(this, ProviderError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Validation errors (bad input)\r\n   */\r\n  export class ValidationError extends DocumentStorageError {\r\n    constructor(message: string) {\r\n      super(`Validation error: ${message}`);\r\n      this.name = 'ValidationError';\r\n      Object.setPrototypeOf(this, ValidationError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Resource not found errors\r\n   */\r\n  export class NotFoundError extends DocumentStorageError {\r\n    constructor(resourceType: string, resourceId: string) {\r\n      super(`${resourceType} not found: ${resourceId}`);\r\n      this.name = 'NotFoundError';\r\n      Object.setPrototypeOf(this, NotFoundError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Permission/authorization errors\r\n   */\r\n  export class PermissionError extends DocumentStorageError {\r\n    constructor(message: string) {\r\n      super(`Permission error: ${message}`);\r\n      this.name = 'PermissionError';\r\n      Object.setPrototypeOf(this, PermissionError.prototype);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Feature not implemented by provider\r\n   */\r\n  export class NotImplementedError extends DocumentStorageError {\r\n    constructor(feature: string, provider: string) {\r\n      super(`Feature '${feature}' not implemented by provider '${provider}'`);\r\n      this.name = 'NotImplementedError';\r\n      Object.setPrototypeOf(this, NotImplementedError.prototype);\r\n    }\r\n  }","import { google } from 'googleapis';\r\nimport { GoogleAuth } from 'google-auth-library';\r\nimport { drive_v3 } from 'googleapis';\r\nimport { GoogleDriveConfig, ServiceAccountKey } from '../../src/types';\r\nimport { ProviderError } from '../../src/types';\r\n\r\n/**\r\n * Google authentication helper for Drive API operations.\r\n *\r\n * Handles authentication and client creation for the Google Drive API\r\n * using a service account with domain-wide delegation.\r\n *\r\n * Key concept: The service account can impersonate any user in the domain\r\n * by setting the 'subject' field in the clientOptions.\r\n */\r\nexport class GoogleAuthHelper {\r\n  /**\r\n   * The service account key used for authentication.\r\n   */\r\n  private serviceAccountKey: ServiceAccountKey;\r\n\r\n  /**\r\n   * The admin email address for the domain.\r\n   */\r\n  private adminEmail: string;\r\n\r\n  /**\r\n   * OAuth scopes required for Drive API access.\r\n   */\r\n  private scopes: string[];\r\n\r\n  /**\r\n   * Cache for Drive API client instances per impersonated user.\r\n   */\r\n  private driveClientCache: Map<string, drive_v3.Drive>;\r\n\r\n  /**\r\n   * Constructs a new GoogleAuthHelper instance.\r\n   * @param config Google Drive configuration with service account credentials.\r\n   */\r\n  constructor(config: GoogleDriveConfig) {\r\n    this.serviceAccountKey = config.serviceAccountKey;\r\n    this.adminEmail = config.adminEmail;\r\n\r\n    // Define OAuth scopes for required permissions\r\n    this.scopes = [\r\n      'https://www.googleapis.com/auth/drive', // Full Drive access\r\n    ];\r\n\r\n    // Initialize the Drive client cache\r\n    this.driveClientCache = new Map();\r\n\r\n    // Validate service account key structure\r\n    this.validateServiceAccountKey();\r\n  }\r\n\r\n  /**\r\n   * Validates that the service account key contains all required fields.\r\n   * @throws {ProviderError} If required fields are missing.\r\n   */\r\n  private validateServiceAccountKey(): void {\r\n    const required: (keyof ServiceAccountKey)[] = ['client_email', 'private_key'];\r\n    const missing = required.filter(field => !this.serviceAccountKey[field]);\r\n\r\n    if (missing.length > 0) {\r\n      throw new ProviderError(\r\n        `Service account key is missing required fields: ${missing.join(', ')}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a GoogleAuth client that impersonates a specific user.\r\n   *\r\n   * Domain-wide delegation steps:\r\n   * - Service account authenticates as itself.\r\n   * - Acts as the specified user (subject).\r\n   * - All API calls appear to come from that user.\r\n   *\r\n   * @param impersonateEmail Email of the user to impersonate.\r\n   * @returns Authenticated GoogleAuth client.\r\n   * @throws {ProviderError} If the client cannot be created.\r\n   */\r\n  private createAuthClient(impersonateEmail: string): GoogleAuth {\r\n    try {\r\n      const auth = new google.auth.GoogleAuth({\r\n        credentials: this.serviceAccountKey,\r\n        scopes: this.scopes,\r\n        clientOptions: {\r\n          subject: impersonateEmail, // Impersonation\r\n        },\r\n      });\r\n\r\n      return auth;\r\n    } catch (error) {\r\n      throw new ProviderError(\r\n        `Failed to create auth client for user: ${impersonateEmail}`,\r\n        error,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates an authenticated Google Drive API client for the impersonated user.\r\n   *\r\n   * All API calls will be made as the impersonated user.\r\n   *\r\n   * @param impersonateEmail Email of the user to impersonate.\r\n   * @returns Google Drive v3 API client.\r\n   * @throws {ProviderError} If the client cannot be created.\r\n   */\r\n  async createDriveClient(impersonateEmail: string): Promise<drive_v3.Drive> {\r\n    // Check cache first\r\n    if (this.driveClientCache.has(impersonateEmail)) {\r\n      return this.driveClientCache.get(impersonateEmail)!;\r\n    }\r\n\r\n    // Create new client\r\n    try {\r\n      const auth = this.createAuthClient(impersonateEmail);\r\n      \r\n      const driveClient = google.drive({\r\n        version: 'v3',\r\n        auth: auth,\r\n      });\r\n\r\n      // Cache the client\r\n      this.driveClientCache.set(impersonateEmail, driveClient);\r\n      return driveClient;\r\n    } catch (error) {\r\n      throw new ProviderError(\r\n        `Failed to create Drive client for user: ${impersonateEmail}`,\r\n        error,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the admin email for the domain.\r\n   * @returns The admin email address.\r\n   */\r\n  getAdminEmail(): string {\r\n    return this.adminEmail;\r\n  }\r\n\r\n  /**\r\n   * Creates an authenticated Google Drive API client for the admin user.\r\n   * \r\n   * This is a convenience method that automatically uses the admin email\r\n   * configured during initialization.\r\n   * \r\n   * @returns Google Drive v3 API client authenticated as admin.\r\n   */\r\n  async createAdminDriveClient(): Promise<drive_v3.Drive> {\r\n    return this.createDriveClient(this.adminEmail);\r\n  }\r\n}","import { drive_v3 } from 'googleapis';\r\nimport { GoogleAuthHelper } from './auth';\r\nimport { ProviderError, NotFoundError, Comment, Revision } from '../../src/types';\r\n\r\n/**\r\n * Helper for Google Drive document operations.\r\n *\r\n * This class provides comprehensive document management capabilities for Google Drive:\r\n *  - Copy documents between users with ownership transfer\r\n *  - Set and retrieve document permissions (read, write, comment access)\r\n *  - Create nested folder structures and manage folder hierarchy\r\n *  - Move documents between folders\r\n *  - Handle authentication and impersonation for multi-user operations\r\n *\r\n * All operations are performed using Google Drive API v3 with proper error handling\r\n * and support for domain-wide delegation to manage documents across user accounts.\r\n */\r\nexport class DocumentOperations {\r\n  /**\r\n   * Creates a new DocumentOperations instance.\r\n   * @param authHelper The GoogleAuthHelper used for authentication and impersonation.\r\n   */\r\n  constructor(private authHelper: GoogleAuthHelper) {}\r\n\r\n  /**\r\n   * Copies a document from the source owner's account.\r\n   *\r\n   * @param sourceDocId Source document ID to copy from.\r\n   * @param sourceOwnerEmail Email of the user who owns/can access the source.\r\n   * @param newName Name for the copied document (optional).\r\n   * @returns Copied file metadata as a Drive file object.\r\n   * @throws {NotFoundError} If the source document is not found.\r\n   * @throws {ProviderError} If the copy operation fails.\r\n   */\r\n  async copyDocument(\r\n    sourceDocId: string,\r\n    sourceOwnerEmail: string,\r\n    newName?: string\r\n  ): Promise<drive_v3.Schema$File> {\r\n    try {\r\n      const sourceDriveClient = await this.authHelper.createDriveClient(sourceOwnerEmail);\r\n\r\n      const copyResponse = await sourceDriveClient.files.copy({\r\n        fileId: sourceDocId,\r\n        requestBody: {\r\n          name: newName\r\n        },\r\n        fields: 'id,name,webViewLink,createdTime,modifiedTime,mimeType' // return these fields in response\r\n      });\r\n\r\n      return copyResponse.data;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', sourceDocId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to copy document: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get document metadata\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @returns Document metadata\r\n   */\r\n  async getDocument(documentId: string): Promise<drive_v3.Schema$File> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.files.get({\r\n        fileId: documentId,\r\n        fields: 'id,name,webViewLink,createdTime,modifiedTime,mimeType,properties'\r\n      });\r\n\r\n      if (!response.data) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to get document ${documentId}: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update document name\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @param newName - New document name\r\n   */\r\n  async updateName(documentId: string, newName: string): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      await adminDriveClient.files.update({\r\n        fileId: documentId,\r\n        requestBody: {\r\n          name: newName\r\n        }\r\n      });\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to update document name ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete document permanently\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   */\r\n  async deleteDocument(documentId: string): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      await adminDriveClient.files.delete({\r\n        fileId: documentId\r\n      });\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to delete document ${documentId}: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create nested folder path\r\n   *\r\n   * Example: \"us_history2/unit1/masters\"\r\n   * Creates:\r\n   * - us_history2/ (if doesn't exist)\r\n   * - us_history2/unit1/ (if doesn't exist)\r\n   * - us_history2/unit1/masters/ (if doesn't exist)\r\n   *\r\n   * Returns: ID of the final folder (masters)\r\n   *\r\n   * Always performed as admin\r\n   *\r\n   * @param path - Folder path (e.g., \"course/unit1/masters\")\r\n   * @returns ID of final folder in path\r\n   */\r\n  async createPath(path: string): Promise<string> {\r\n    try {\r\n      // Clean up path (remove leading/trailing slashes, empty segments)\r\n      const segments = path\r\n        .split('/')\r\n        .map((s) => s.trim())\r\n        .filter((s) => s.length > 0);\r\n\r\n      if (segments.length === 0) {\r\n        throw new ProviderError('Folder path cannot be empty');\r\n      }\r\n\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      let parentId: string | null = null;\r\n\r\n      // Create each folder in the path\r\n      for (const folderName of segments) {\r\n\r\n        parentId = await this._findOrCreateFolder(adminDriveClient, folderName, parentId);\r\n\r\n      }\r\n\r\n      return parentId!;\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to create folder path \"${path}\": ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find existing folder or create new one\r\n   *\r\n   * @param drive - Authenticated Drive client\r\n   * @param folderName - Name of folder to find/create\r\n   * @param parentId - Parent folder ID (null for root)\r\n   * @returns Folder ID\r\n   */\r\n  private async _findOrCreateFolder(\r\n    drive: drive_v3.Drive,\r\n    folderName: string,\r\n    parentId: string | null\r\n  ): Promise<string> {\r\n    // Step 1: Search for existing folder\r\n    const existingFolder = await this._findFolder(drive, folderName, parentId);\r\n\r\n    if (existingFolder) {\r\n      return existingFolder;\r\n    }\r\n\r\n    // Step 2: Create new folder if not found\r\n    return await this._createFolder(drive, folderName, parentId);\r\n  }\r\n\r\n  /**\r\n   * Search for existing folder\r\n   *\r\n   * @param drive - Authenticated Drive client\r\n   * @param folderName - Folder name to search for\r\n   * @param parentId - Parent folder ID (null for root)\r\n   * @returns Folder ID if found, null otherwise\r\n   */\r\n  private async _findFolder(\r\n    drive: drive_v3.Drive,\r\n    folderName: string,\r\n    parentId: string | null\r\n  ): Promise<string | null> {\r\n    try {\r\n      // Escape single quotes in folder name\r\n      const escapedName = folderName.replace(/'/g, \"\\\\'\");\r\n\r\n      // Build query\r\n      const queryParts = [\r\n        `name='${escapedName}'`,\r\n        `mimeType='application/vnd.google-apps.folder'`,\r\n        `trashed=false`\r\n      ];\r\n\r\n      // Add parent condition\r\n      if (parentId) {\r\n        queryParts.push(`'${parentId}' in parents`);\r\n      } else {\r\n        // Search in root (My Drive)\r\n        queryParts.push(`'root' in parents`);\r\n      }\r\n\r\n      const query = queryParts.join(' and ');\r\n\r\n      const response = await drive.files.list({\r\n        q: query,\r\n        fields: 'files(id,name)',\r\n        pageSize: 1 // We only need first match\r\n      });\r\n\r\n      const folders = response.data.files || [];\r\n\r\n      if (folders.length > 0) {\r\n        return folders[0].id!;\r\n      }\r\n\r\n      return null;\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      console.warn(`  ⚠️ Error searching for folder ${folderName}:`, errorMessage);\r\n      return null; // If search fails, we'll create it\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create new folder\r\n   *\r\n   * @param drive - Authenticated Drive client\r\n   * @param folderName - Name for new folder\r\n   * @param parentId - Parent folder ID (null for root)\r\n   * @returns New folder ID\r\n   */\r\n  private async _createFolder(\r\n    drive: drive_v3.Drive,\r\n    folderName: string,\r\n    parentId: string | null\r\n  ): Promise<string> {\r\n    const folderMetadata: drive_v3.Schema$File = {\r\n      name: folderName,\r\n      mimeType: 'application/vnd.google-apps.folder',\r\n      parents: parentId ? [parentId] : undefined\r\n    };\r\n\r\n    const response = await drive.files.create({\r\n      requestBody: folderMetadata,\r\n      fields: 'id,name'\r\n    });\r\n\r\n    if (!response.data || !response.data.id) {\r\n      throw new ProviderError(`Failed to create folder: ${folderName}`);\r\n    }\r\n\r\n    return response.data.id;\r\n  }\r\n\r\n  /**\r\n   * Moves a document to a specific folder.\r\n   * Removes document from all current parent folders and places in new folder.\r\n   * Always performed as admin.\r\n   *\r\n   * @param fileId The ID of the file to move.\r\n   * @param folderId The ID of the destination folder.\r\n   * @throws {ProviderError} If the move operation fails.\r\n   */\r\n  async moveToFolder(fileId: string, folderId: string): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Get current parents\r\n      const file = await adminDriveClient.files.get({\r\n        fileId: fileId,\r\n        fields: 'parents'\r\n      });\r\n\r\n      const previousParents = file.data.parents?.join(',') || '';\r\n\r\n      // Move file to new folder and remove from old parents\r\n      await adminDriveClient.files.update({\r\n        fileId: fileId,\r\n        addParents: folderId,\r\n        removeParents: previousParents,\r\n        fields: 'id,parents'\r\n      });\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to move document to folder: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves comments for a document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Comment objects.\r\n   * @throws {NotFoundError} If the document is not found.\r\n   * @throws {ProviderError} If the operation fails.\r\n   */\r\n  async getComments(documentId: string): Promise<Comment[]> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.comments.list({\r\n        fileId: documentId,\r\n        fields: 'comments(id,content,author,createdTime,resolved,replies)'\r\n      });\r\n\r\n      const comments = response.data.comments || [];\r\n\r\n      return comments.map((comment) => ({\r\n        comment_id: comment.id!,\r\n        author: comment.author?.displayName  || 'Unknown',\r\n        content: comment.content!,\r\n        created_at: comment.createdTime!,\r\n        resolved: comment.resolved || false,\r\n        replies: (comment.replies || []).map((reply) => ({\r\n          reply_id: reply.id!,\r\n          author: reply.author?.displayName  || 'Unknown',\r\n          content: reply.content!,\r\n          created_at: reply.createdTime!\r\n        }))\r\n      }));\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to get comments for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves revisions for a document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Revision objects.\r\n   * @throws {NotFoundError} If the document is not found.\r\n   * @throws {ProviderError} If the operation fails.\r\n   */\r\n  async getRevisions(documentId: string): Promise<Revision[]> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.revisions.list({\r\n        fileId: documentId,\r\n        fields: 'revisions(id,modifiedTime,lastModifyingUser,exportLinks)'\r\n      });\r\n\r\n      const revisions = response.data.revisions || [];\r\n\r\n      return revisions.map((rev) => ({\r\n        revision_id: rev.id!,\r\n        modified_time: rev.modifiedTime!,\r\n        modified_by: rev.lastModifyingUser?.emailAddress || 'Unknown',\r\n        export_links: rev.exportLinks || undefined\r\n      }));\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to get revisions for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n}\r\n","import { GoogleAuthHelper } from './auth';\r\nimport {AccessControl, ProviderError, NotFoundError } from '../../src/types';\r\n\r\n/**\r\n * Permission management for Google Drive documents.\r\n *\r\n * Handles ownership transfers and permission settings for documents.\r\n */\r\nexport class DocumentPermissions {\r\n  /**\r\n   * Helper for Google authentication and impersonation.\r\n   */\r\n  private authHelper: GoogleAuthHelper;\r\n\r\n  /**\r\n   * Constructs a new DocumentPermissions instance.\r\n   * @param authHelper The authentication helper for creating Drive clients.\r\n   */\r\n  constructor(authHelper: GoogleAuthHelper) {\r\n    this.authHelper = authHelper;\r\n  }\r\n\r\n  /**\r\n   * Transfers ownership of a document to the admin.\r\n   *\r\n   * @param sourceOwnerEmail Email of the current document owner.\r\n   * @param fileId The ID of the file to transfer ownership of.\r\n   * @throws {ProviderError} If the ownership transfer fails.\r\n   */\r\n  async transferToAdmin(sourceOwnerEmail: string, fileId: string): Promise<void> {\r\n    try {\r\n      const adminEmail = this.authHelper.getAdminEmail();\r\n      const sourceDriveClient = await this.authHelper.createDriveClient(sourceOwnerEmail);\r\n\r\n      await sourceDriveClient.permissions.create({\r\n        fileId: fileId,\r\n        requestBody: {\r\n          role: 'owner',\r\n          type: 'user',\r\n          emailAddress: adminEmail\r\n        },\r\n        transferOwnership: true\r\n      });\r\n\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const permissions = await adminDriveClient.permissions.list({\r\n        fileId: fileId,\r\n        fields: 'permissions(id,emailAddress,role)'\r\n      });\r\n\r\n      // Find teacher's permission\r\n      const teacherPermission = permissions.data.permissions?.find(\r\n        (p) => p.emailAddress === sourceOwnerEmail\r\n      );\r\n\r\n      if (teacherPermission?.id) {\r\n        await adminDriveClient.permissions.delete({\r\n          fileId: fileId,\r\n          permissionId: teacherPermission.id\r\n        });\r\n      }\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to transfer ownership to admin: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set permissions on a document\r\n   * Replaces ALL existing permissions except owner\r\n   * Always performed as admin\r\n   *\r\n   * Flow:\r\n   * 1. Get all existing permissions\r\n   * 2. Delete all non-owner permissions\r\n   * 3. Create new permissions from accessControl array\r\n   *\r\n   * @param documentId - Document ID\r\n   * @param accessControl - Array of access control rules\r\n   */\r\n  async setPermissions(documentId: string, accessControl: AccessControl[]): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Step 1: Get existing permissions\r\n      const existingPermissions = await adminDriveClient.permissions.list({\r\n        fileId: documentId,\r\n        fields: 'permissions(id,role,emailAddress,type)'\r\n      });\r\n\r\n      const permissions = existingPermissions.data.permissions || [];\r\n\r\n      // Step 2: Delete all non-owner permissions\r\n      for (const permission of permissions) {\r\n        // Never delete owner permission\r\n        if (permission.role === 'owner') {\r\n          continue;\r\n        }\r\n\r\n        if (permission.id) {\r\n          try {\r\n            await adminDriveClient.permissions.delete({\r\n              fileId: documentId,\r\n              permissionId: permission.id\r\n            });\r\n          } catch (error) {\r\n            console.warn(`Failed to remove permission ${permission.id}:`, error);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Step 3: Create new permissions\r\n      for (const ac of accessControl) {\r\n        const role = this._mapAccessLevelToRole(ac.access_level);\r\n\r\n        await adminDriveClient.permissions.create({\r\n          fileId: documentId,\r\n          requestBody: {\r\n            role: role,\r\n            type: 'user',\r\n            emailAddress: ac.user\r\n          },\r\n          sendNotificationEmail: false // Don't spam users with emails\r\n        });\r\n\r\n      }\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to set permissions on document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current permissions on a document\r\n   * Excludes owner permission\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @returns Array of access control rules\r\n   */\r\n  async getPermissions(documentId: string): Promise<AccessControl[]> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.permissions.list({\r\n        fileId: documentId,\r\n        fields: 'permissions(id,role,emailAddress,type)'\r\n      });\r\n\r\n      const permissions = response.data.permissions || [];\r\n\r\n      // Filter out owner and convert to AccessControl format\r\n      const accessControl: AccessControl[] = permissions\r\n        .filter((p) => p.role !== 'owner' && p.emailAddress)\r\n        .map((p) => ({\r\n          user: p.emailAddress!,\r\n          access_level: this._mapRoleToAccessLevel(p.role!)\r\n        }));\r\n\r\n      return accessControl;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to get permissions for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Map our access level to Google Drive role\r\n   *\r\n   * @param accessLevel - Our access level (read, read_write, comment)\r\n   * @returns Google Drive role (reader, writer, commenter)\r\n   */\r\n  private _mapAccessLevelToRole(accessLevel: string): string {\r\n    const mapping: Record<string, string> = {\r\n      read: 'reader',\r\n      read_write: 'writer',\r\n      comment: 'commenter'\r\n    };\r\n\r\n    const role = mapping[accessLevel];\r\n    if (!role) {\r\n      throw new ProviderError(\r\n        `Invalid access level: ${accessLevel}. Must be read, read_write, or comment`\r\n      );\r\n    }\r\n\r\n    return role;\r\n  }\r\n\r\n  /**\r\n   * Map Google Drive role to our access level\r\n   *\r\n   * @param role - Google Drive role (reader, writer, commenter)\r\n   * @returns Our access level (read, read_write, comment)\r\n   */\r\n  private _mapRoleToAccessLevel(role: string): 'read' | 'read_write' | 'comment' {\r\n    const mapping: Record<string, 'read' | 'read_write' | 'comment'> = {\r\n      reader: 'read',\r\n      writer: 'read_write',\r\n      commenter: 'comment'\r\n    };\r\n\r\n    return mapping[role] || 'read'; // Default to read if unknown\r\n  }\r\n}\r\n","import { GoogleAuthHelper } from './auth';\r\nimport { Document, NotFoundError, ProviderError, SearchDocumentsResult } from '../../src/types';\r\nimport { drive_v3 } from 'googleapis';\r\n\r\n/**\r\n * Metadata management for Google Drive documents.\r\n *\r\n * Handles retrieval and updates of document metadata.\r\n */\r\nexport class DocumentMetadata {\r\n  /**\r\n   * Helper for Google authentication and impersonation.\r\n   */\r\n  private authHelper: GoogleAuthHelper;\r\n\r\n  /**\r\n   * Constructs a new DocumentMetadata instance.\r\n   * @param authHelper The authentication helper for creating Drive clients.\r\n   */\r\n  constructor(authHelper: GoogleAuthHelper) {\r\n    this.authHelper = authHelper;\r\n  }\r\n\r\n  /**\r\n   * Set custom metadata on a document\r\n   * Stored as Google Drive file properties\r\n   * Always performed as admin\r\n   *\r\n   * Note: Google Drive properties are key-value strings.\r\n   * Non-string values are JSON-stringified.\r\n   *\r\n   * @param documentId - Document ID\r\n   * @param metadata - Key-value metadata object\r\n   */\r\n  async setMetadata(documentId: string, metadata: Record<string, unknown>): Promise<void> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Convert all values to strings (Google Drive requirement)\r\n      const properties: Record<string, string> = {};\r\n      for (const [key, value] of Object.entries(metadata)) {\r\n        if (value === null || value === undefined) {\r\n          properties[key] = '';\r\n        } else if (typeof value === 'string') {\r\n          properties[key] = value;\r\n        } else {\r\n          // JSON stringify objects, numbers, booleans, arrays\r\n          properties[key] = JSON.stringify(value);\r\n        }\r\n      }\r\n\r\n      await adminDriveClient.files.update({\r\n        fileId: documentId,\r\n        requestBody: {\r\n          properties: properties\r\n        },\r\n        fields: 'properties'\r\n      });\r\n\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(\r\n        `Failed to set metadata on document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get custom metadata from a document\r\n   * Always performed as admin\r\n   *\r\n   * @param documentId - Document ID\r\n   * @returns Metadata object (with values parsed back from strings)\r\n   */\r\n  async getMetadata(documentId: string): Promise<Record<string, unknown>> {\r\n    try {\r\n      const adminDriveClient = await this.authHelper.createAdminDriveClient();\r\n\r\n      const response = await adminDriveClient.files.get({\r\n        fileId: documentId,\r\n        fields: 'properties'\r\n      });\r\n\r\n      const properties = response.data.properties || {};\r\n\r\n      // Parse values back (attempt JSON parse, fallback to string)\r\n      const metadata: Record<string, unknown> = {};\r\n      for (const [key, value] of Object.entries(properties)) {\r\n        if (value === '') {\r\n          metadata[key] = null;\r\n        } else {\r\n          try {\r\n            // Try to parse as JSON (for objects, numbers, booleans, arrays)\r\n            metadata[key] = JSON.parse(value);\r\n          } catch {\r\n            // Not JSON, keep as string\r\n            metadata[key] = value;\r\n          }\r\n        }\r\n      }\r\n\r\n      return metadata;\r\n    } catch (error: unknown) {\r\n      if (error && typeof error === 'object' && 'code' in error && error.code === 404) {\r\n        throw new NotFoundError('Document', documentId);\r\n      }\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n      throw new ProviderError(\r\n        `Failed to get metadata for document ${documentId}: ${errorMessage}`,\r\n        error\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search documents by metadata filters with token-based pagination.\r\n   * Uses Google Drive query API to search by custom properties.\r\n   * Always performed as admin.\r\n   *\r\n   * Example filters:\r\n   * { activity_id: 'act_123', document_type: 'student_copy' }\r\n   *\r\n   * Becomes Google Drive query:\r\n   * \"properties has { key='activity_id' and value='act_123' } and\r\n   *  properties has { key='document_type' and value='student_copy' }\"\r\n   *\r\n   * @param filters - Metadata key-value filters\r\n   * @param limit - Maximum results per page (default: 20, max: 100)\r\n   * @param pageToken - Token from previous response for next page\r\n   * @returns Search results with documents and next page token\r\n   */\r\n  async searchByMetadata(\r\n    filters: Record<string, unknown>,\r\n    limit: number = 20,\r\n    pageToken?: string\r\n  ): Promise<SearchDocumentsResult> {\r\n    try {\r\n      // Validate limit\r\n      if (limit < 1 || limit > 100) {\r\n        throw new ProviderError('Limit must be between 1 and 100');\r\n      }\r\n\r\n      const adminDrive = await this.authHelper.createAdminDriveClient();\r\n\r\n      // Build query from filters\r\n      const queryParts: string[] = [];\r\n\r\n      for (const [key, value] of Object.entries(filters)) {\r\n        // Convert value to string (same as setMetadata)\r\n        let stringValue: string;\r\n        if (value === null || value === undefined) {\r\n          stringValue = '';\r\n        } else if (typeof value === 'string') {\r\n          stringValue = value;\r\n        } else {\r\n          stringValue = JSON.stringify(value);\r\n        }\r\n\r\n        // Escape single quotes in value\r\n        const escapedValue = stringValue.replace(/'/g, \"\\\\'\");\r\n\r\n        // Build query part\r\n        queryParts.push(`properties has { key='${key}' and value='${escapedValue}' }`);\r\n      }\r\n\r\n      // Add \"not trashed\" filter\r\n      queryParts.push('trashed=false');\r\n\r\n      // Combine all query parts\r\n      const query = queryParts.join(' and ');\r\n\r\n      // Execute search with pagination\r\n      const response = await adminDrive.files.list({\r\n        q: query,\r\n        fields:\r\n          'nextPageToken, files(id,name,webViewLink,createdTime,modifiedTime,mimeType,properties)',\r\n        pageSize: limit,\r\n        pageToken: pageToken, // Use token if provided\r\n        orderBy: 'modifiedTime desc' // Most recently modified first\r\n      });\r\n\r\n      const files = response.data.files || [];\r\n      const nextPageToken = response.data.nextPageToken;\r\n\r\n      // Transform to Document format\r\n      const documents: Document[] = files.map((file) => this._toDocumentObject(file));\r\n\r\n      return {\r\n        documents,\r\n        nextPageToken,\r\n        limit\r\n      };\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n\r\n      throw new ProviderError(`Failed to search documents by metadata ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts a Google Drive file object to the internal Document format.\r\n   *\r\n   * @param file The Google Drive file to convert.\r\n   * @returns The corresponding Document object.\r\n   */\r\n  private _toDocumentObject(file: drive_v3.Schema$File): Document {\r\n    // Convert Google Drive properties to metadata\r\n    const metadata: Record<string, unknown> = {};\r\n\r\n    if (file.properties) {\r\n      for (const [key, value] of Object.entries(file.properties)) {\r\n        if (value !== null && value !== undefined) {\r\n          // Try to parse JSON values, otherwise keep as string\r\n          try {\r\n            metadata[key] = JSON.parse(value);\r\n          } catch {\r\n            metadata[key] = value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      document_id: file.id!,\r\n      storage_reference: file.id!,\r\n      name: file.name || 'Untitled',\r\n      access_url: file.webViewLink || `https://docs.google.com/document/d/${file.id}/edit`,\r\n      created_at: file.createdTime || new Date().toISOString(),\r\n      updated_at: file.modifiedTime || undefined,\r\n      metadata: Object.keys(metadata).length > 0 ? metadata : undefined\r\n    };\r\n  }\r\n}\r\n","import { drive_v3 } from 'googleapis';\r\nimport { IStorageProvider } from '../IStorageProvider';\r\nimport {\r\n  Document,\r\n  CreateDocumentRequest,\r\n  GoogleDriveConfig,\r\n  ProviderError,\r\n  AccessControl,\r\n  SearchDocumentsResult,\r\n  Comment,\r\n  Revision\r\n} from '../../src/types';\r\nimport { GoogleAuthHelper } from './auth';\r\nimport { DocumentOperations } from './operations';\r\nimport { DocumentPermissions } from './permissions';\r\nimport { DocumentMetadata } from './metadata';\r\n\r\n/**\r\n * Google Drive Storage Provider implementation.\r\n *\r\n * Implements the {@link IStorageProvider} interface for Google Drive.\r\n * Orchestrates authentication, document operations, permissions, and metadata\r\n * to provide complete document management functionality.\r\n */\r\nexport class GoogleDriveProvider implements IStorageProvider {\r\n  /**\r\n   * Helper for Google authentication and impersonation.\r\n   */\r\n  private authHelper: GoogleAuthHelper;\r\n\r\n  /**\r\n   * Handles document-level operations (copy, move, get, folder management).\r\n   */\r\n  private operations: DocumentOperations;\r\n\r\n  /**\r\n   * Handles permission and ownership operations.\r\n   */\r\n  private permissions: DocumentPermissions;\r\n\r\n  /**\r\n   * Handles metadata operations.\r\n   */\r\n  private metadata: DocumentMetadata;\r\n\r\n  /**\r\n   * Constructs a new GoogleDriveProvider instance.\r\n   * @param config The configuration object for Google Drive integration.\r\n   */\r\n  constructor(config: GoogleDriveConfig) {\r\n    this.authHelper = new GoogleAuthHelper(config);\r\n    this.operations = new DocumentOperations(this.authHelper);\r\n    this.permissions = new DocumentPermissions(this.authHelper);\r\n    this.metadata = new DocumentMetadata(this.authHelper);\r\n  }\r\n\r\n  // ==================== DOCUMENT OPERATIONS ====================\r\n\r\n  /**\r\n   * Copies a document in Google Drive according to the request details.\r\n   *\r\n   * Steps:\r\n   * 1. Copies the source document, impersonating the source owner.\r\n   * 2. Transfers ownership to admin.\r\n   * 3. Creates the target folder structure if `folder_path` is provided and moves document.\r\n   * 4. Sets permissions if `access_control` is specified.\r\n   * 5. Sets metadata if `metadata` is specified.\r\n   * 6. Transforms the copied file into the Document format.\r\n   *\r\n   * @param request The document creation request, including source reference, owner, name, folder path, access control, and metadata.\r\n   * @returns The created Document object.\r\n   * @throws {ProviderError} If any step fails during the process.\r\n   */\r\n  async copyDocumentFromSource(request: CreateDocumentRequest): Promise<Document> {\r\n    try {\r\n      // 1. Copy document\r\n      const copiedFile = await this.operations.copyDocument(\r\n        request.source_reference,\r\n        request.source_owner,\r\n        request.name\r\n      );\r\n\r\n      // 2. Transfer ownership to admin\r\n      await this.permissions.transferToAdmin(request.source_owner, copiedFile.id!);\r\n\r\n      // 3. Move to folder (if specified)\r\n      if (request.folder_path) {\r\n        const folderId = await this.operations.createPath(request.folder_path);\r\n        await this.operations.moveToFolder(copiedFile.id!, folderId);\r\n      }\r\n\r\n      // 4. Set permissions (if specified)\r\n      if (request.access_control && request.access_control.length > 0) {\r\n        await this.permissions.setPermissions(copiedFile.id!, request.access_control);\r\n      }\r\n\r\n      // 5. Set metadata (if specified)\r\n      if (request.metadata) {\r\n        await this.metadata.setMetadata(copiedFile.id!, request.metadata);\r\n      }\r\n\r\n      // 6. Transform to Document\r\n      return this._toDocumentObject(copiedFile);\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to create document: ${errorMessage}`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves a document's metadata from Google Drive and transforms it into the Document format.\r\n   *\r\n   * @param documentId - The unique identifier of the Google Drive document.\r\n   * @returns The corresponding Document object in the internal format.\r\n   */\r\n  async getDocument(documentId: string): Promise<Document> {\r\n    const file = await this.operations.getDocument(documentId);\r\n    return this._toDocumentObject(file);\r\n  }\r\n\r\n  /**\r\n   * Updates a document's name and/or metadata in Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - ID of the document to update.\r\n   * @param updates - Object containing the new name and/or metadata to set.\r\n   * @returns The updated Document object.\r\n   */\r\n  async updateDocument(\r\n    documentId: string,\r\n    updates: { name?: string; metadata?: Record<string, unknown> }\r\n  ): Promise<Document> {\r\n    try {\r\n      // Update name if provided\r\n      if (updates.name) {\r\n        await this.operations.updateName(documentId, updates.name);\r\n      }\r\n\r\n      // Update metadata if provided\r\n      if (updates.metadata) {\r\n        // Merge with existing metadata\r\n        const existingMetadata = await this.metadata.getMetadata(documentId);\r\n        const mergedMetadata = { ...existingMetadata, ...updates.metadata };\r\n        await this.metadata.setMetadata(documentId, mergedMetadata);\r\n      }\r\n\r\n      // Return updated document\r\n      return await this.getDocument(documentId);\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new ProviderError(`Failed to update document: ${errorMessage}`, error);\r\n    }\r\n  }\r\n  /**\r\n   * Deletes a document permanently by its ID from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document to delete.\r\n   * @returns A promise that resolves when the document is deleted.\r\n   */\r\n  async deleteDocument(documentId: string): Promise<void> {\r\n    await this.operations.deleteDocument(documentId);\r\n  }\r\n\r\n  /**\r\n   * Sets access permissions for a document, replacing all existing non-owner permissions.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document to update permissions for.\r\n   * @param accessControl - Array of AccessControl rules to apply.\r\n   * @returns A promise that resolves when permissions are set.\r\n   */\r\n  async setPermissions(documentId: string, accessControl: AccessControl[]): Promise<void> {\r\n    await this.permissions.setPermissions(documentId, accessControl);\r\n  }\r\n\r\n\r\n  \r\n  /**\r\n   * Searches for documents by metadata filters in Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param filters - Key-value pairs of metadata fields to filter.\r\n   * @param limit - Maximum number of documents to return (default: 20).\r\n   * @param offset - Pagination offset (default: 0).\r\n   * @returns A promise resolving to a SearchDocumentsResult with found documents.\r\n   */\r\n  async searchByMetadata(\r\n    filters: Record<string, unknown>,\r\n    limit: number = 20,\r\n    pageToken?: string\r\n  ): Promise<SearchDocumentsResult> {\r\n    return await this.metadata.searchByMetadata(filters, limit, pageToken);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Retrieves comments for a specific document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Comment objects.\r\n   */\r\n  async getComments(documentId: string): Promise<Comment[]> {\r\n    return await this.operations.getComments(documentId);\r\n  }\r\n\r\n  /**\r\n   * Retrieves revision history for a specific document from Google Drive.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to an array of Revision objects.\r\n   */\r\n  async getRevisions(documentId: string): Promise<Revision[]> {\r\n    return await this.operations.getRevisions(documentId);\r\n  }\r\n  \r\n\r\n  // ==================== HELPER METHODS ====================\r\n\r\n  /**\r\n   * Converts a Google Drive file object to the internal Document format.\r\n   *\r\n   * @param file The Google Drive file to convert.\r\n   * @returns The corresponding Document object.\r\n   */\r\n  private _toDocumentObject(file: drive_v3.Schema$File): Document {\r\n    // Convert Google Drive properties to metadata\r\n    const metadata: Record<string, unknown> = {};\r\n\r\n    if (file.properties) {\r\n      for (const [key, value] of Object.entries(file.properties)) {\r\n        if (value !== null && value !== undefined) {\r\n          // Try to parse JSON values, otherwise keep as string\r\n          try {\r\n            metadata[key] = JSON.parse(value);\r\n          } catch {\r\n            metadata[key] = value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      document_id: file.id!,\r\n      storage_reference: file.id!,\r\n      name: file.name || 'Untitled',\r\n      access_url: file.webViewLink || `https://docs.google.com/document/d/${file.id}/edit`,\r\n      created_at: file.createdTime || new Date().toISOString(),\r\n      updated_at: file.modifiedTime || undefined,\r\n      metadata: Object.keys(metadata).length > 0 ? metadata : undefined\r\n    };\r\n  }\r\n}\r\n","import { GoogleDriveProvider } from '../providers/google-drive/GoogleDriveProvider';\r\nimport {\r\n  Document,\r\n  CreateDocumentRequest,\r\n  GoogleDriveConfig,\r\n  ValidationError,\r\n  ProviderType,\r\n  AccessControl,\r\n  SearchDocumentsResult,\r\n  Comment,\r\n  Revision\r\n} from './types';\r\n\r\nimport { IStorageProvider } from '../providers/IStorageProvider';\r\n\r\n/**\r\n * Configuration options for the DocumentManager.\r\n * @property provider The type of storage provider ('google_drive' or 's3').\r\n * @property config Provider-specific configuration. Currently only GoogleDriveConfig is supported.\r\n */\r\ninterface DocumentManagerConfig {\r\n  /** The type of storage provider to use. */\r\n  provider: ProviderType;\r\n\r\n  /** Provider-specific configuration. */\r\n  config: GoogleDriveConfig; // Will be union type when S3 added\r\n}\r\n\r\n/**\r\n * Main facade class providing a unified interface for document operations.\r\n * Automatically instantiates the correct storage provider based on configuration.\r\n */\r\nexport class DocumentManager {\r\n  /** The underlying storage provider instance. */\r\n  private provider: IStorageProvider;\r\n\r\n  /**\r\n   * Constructs a DocumentManager instance with the specified configuration.\r\n   * @param options Configuration for selecting and initializing the storage provider.\r\n   * @throws {ValidationError} If the provider type is unsupported.\r\n   * @throws {Error} If the S3 provider is selected (not yet implemented).\r\n   */\r\n  constructor(options: DocumentManagerConfig) {\r\n    // Create provider based on type\r\n    if (options.provider === ProviderType.GOOGLE_DRIVE) {\r\n      this.provider = new GoogleDriveProvider(options.config);\r\n    } else if (options.provider === ProviderType.S3) {\r\n      throw new Error('S3 provider not yet implemented');\r\n    } else {\r\n      throw new ValidationError(`Unsupported provider: ${options.provider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new document from the specified source.\r\n   * @param request Details for the document to be created.\r\n   * @returns The created Document object.\r\n   */\r\n  async createDocument(request: CreateDocumentRequest): Promise<Document> {\r\n    return await this.provider.copyDocumentFromSource(request);\r\n  }\r\n\r\n  /**\r\n   * Get document by ID\r\n   * @param documentId - The unique identifier of the document.\r\n   * @returns A promise resolving to the found Document object, if it exists.\r\n   */\r\n  async getDocument(documentId: string): Promise<Document> {\r\n    return await this.provider.getDocument(documentId);\r\n  }\r\n\r\n  /**\r\n   * Updates a document's name and/or metadata.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - ID of the document to update.\r\n   * @param updates - Object containing the new name and/or metadata to set.\r\n   * @returns The updated Document object.\r\n   */\r\n  async updateDocument(\r\n    documentId: string,\r\n    updates: { name?: string; metadata?: Record<string, unknown> }\r\n  ): Promise<Document> {\r\n    return await this.provider.updateDocument(documentId, updates);\r\n  }\r\n\r\n  /**\r\n   * Deletes a document permanently by its document ID.\r\n   * Always performed as admin (who owns all documents).\r\n   *\r\n   * @param documentId - The unique identifier of the document to delete.\r\n   * @returns A promise that resolves when the document is deleted.\r\n   */\r\n  async deleteDocument(documentId: string): Promise<void> {\r\n    return await this.provider.deleteDocument(documentId);\r\n  }\r\n\r\n  /**\r\n   * Sets the access control (permissions) for a document, replacing all existing permissions.\r\n   *\r\n   * @param documentId - The unique identifier of the document to update permissions for.\r\n   * @param accessControl - An array of AccessControl objects specifying the new permissions.\r\n   * @returns A promise that resolves when permissions are set.\r\n   */\r\n  async setAccessControl(documentId: string, accessControl: AccessControl[]): Promise<void> {\r\n    return await this.provider.setPermissions(documentId, accessControl);\r\n  }\r\n\r\n  /**\r\n   * Lists or searches for documents matching the provided metadata filters.\r\n   *\r\n   * @param filters - An object containing metadata key-value pairs to filter documents.\r\n   * @param limit - The maximum number of documents to retrieve (default: 20).\r\n   * @param offset - The number of documents to skip before starting to collect the result set (default: 0).\r\n   * @returns A promise that resolves to a SearchDocumentsResult containing the found documents and any pagination info.\r\n   */\r\n  async listDocuments(\r\n    filters: Record<string, unknown>,\r\n    limit: number = 20,\r\n    pageToken?: string\r\n  ): Promise<SearchDocumentsResult> {\r\n    return await this.provider.searchByMetadata(filters, limit, pageToken);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Retrieves comments for a given document, if supported by the provider.\r\n   *\r\n   * @param documentId - The unique identifier of the document to get comments for.\r\n   * @returns A promise that resolves to an array of Comment objects.\r\n   * @throws Error if comments are not supported by the underlying provider.\r\n   */\r\n  async getComments(documentId: string): Promise<Comment[]> {\r\n    \r\n    if (!this.provider.getComments) {\r\n      throw new Error('Comments not supported by this provider');\r\n    }\r\n    \r\n    return await this.provider.getComments(documentId);\r\n  }\r\n\r\n\r\n  /**\r\n   * Retrieves the revision history for a given document, if supported by the provider.\r\n   *\r\n   * @param documentId - The unique identifier of the document to get revisions for.\r\n   * @returns A promise that resolves to an array of Revision objects.\r\n   * @throws Error if revisions are not supported by the underlying provider.\r\n   */\r\n  async getRevisions(documentId: string): Promise<Revision[]> {\r\n    \r\n    if (!this.provider.getRevisions) {\r\n      throw new Error('Revisions not supported by this provider');\r\n    }\r\n    \r\n    return await this.provider.getRevisions(documentId);\r\n  }\r\n}\r\n"],"mappings":"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"}